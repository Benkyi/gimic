      PROGRAM JONAS
C
C QUICK AND DIRTY PROGRAM TO GET DENSITY MATRIX AND PERTURBED
C DENSITY MATRICES
C
C ORIGINAL VERSION: HF-SCF DENSITIES
C MODIFIED VERSION: CORRELATED DENSITIES
C
CEND
C
C J. GAUSS UNIVERSITY OF MAINZ, 2002
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      PARAMETER (MAXCOR=2 000 000)
      LOGICAL DEBUG
      DIMENSION SCR(MAXCOR),IP(8),IRREPB(3),NBASI(8)
      DIMENSION IOFFMO(8),IOFFDMO(8)
      INTEGER DIRPRD,POP,VRT
C
      COMMON/MACHSP/IINTLN,IFLTLN,IINTFP,IALONE,IBITWD
      COMMON/SYMINF/NSTART,NIRREP,IRREPS(255,2),DIRPRD(8,8)
      COMMON/SYM/POP(8,2),VRT(8,2),NT(2),NF1(2),NF2(2)
      COMMON/SYMPOP/IRPDPD(8,22),ISYTYP(2,500),ID(18)
      COMMON/SYMLOC/ISYMOFF(8,8,25) 
      COMMON/FLAGS/IFLAGS(100)
      COMMON/INFO/NOCA,NOCB,NVRTA,NVRTB
      COMMON/PERT/NTPERT,NPERT(8),IPERT(8),IXPERT,IYPERT,IZPERT,
     &            IYZPERT,IXZPERT,IXYPERT,ITRANSX,ITRANSY,ITRANSZ,
     &            NUCIND                                                        
C 
      DATA FACT/26.62568098450085D+00/
      DATA HALFM/-.5D0/
C
C INITIALIZE THIS MODULE
C
      CALL CRAPSI(SCR,IUHF,0)
C
C DEBUG FLAG
C
      DEBUG=.TRUE.

      open(42, file='XDENS', status='unknown')
C
C NBAS NUMBER OF BASIS FUNCTIONS
C
      NBAS=NOCA+NVRTA
      NBAS2=NBAS*NBAS
C
C GET NUMBER OF BASIS FUNCTIONS CONSIDERING A CARTESIAN BASIS
C
      IONE=1
      CALL GETREC(20,'JOBARC','NAOBASFN',IONE,NBASC)
c     write(*,*) 'NBAS[C]', NBAS, NBASC
C
C SYMMETRY STUFF, NUMBER OF BASIS FUNCTIONS PER IRREP 
C
      DO 2001 IRREP=1,NIRREP
       NBASI(IRREP)=POP(IRREP,1)+VRT(IRREP,1)
2001  CONTINUE
C
C UNPERTURBED HF-SCF DENSITY MATRIX ...
C******************************************************
      IDENS=1
      ISTART=IDENS+NBASC*NBASC
C
C READ FROM JOBARC 
C
      IF(IFLAGS(2).EQ.0) THEN
C
C HF-SCF CASE
C
C  READ AO-DENSITY FROM JOBARC
C
       CALL GETREC(20,'JOBARC','SCFDENSA',NBAS2*IINTFP,SCR(IDENS))
C
C SAO --> CAO TRANSFORMATION; TWO XGEMM CALLS
C
       ISTART2=ISTART
       ISTART3=ISTART2+NBAS*NBASC
       CALL GETREC(20,'JOBARC','CMP2ZMAT',NBAS*NBASC*IINTFP,
     &             SCR(ISTART2))
       CALL XGEMM('N','N',NBASC,NBAS,NBAS,1.D0,SCR(ISTART2),
     &             NBASC,SCR(IDENS),NBAS,0.D0,SCR(ISTART3),NBASC)
       CALL XGEMM('N','T',NBASC,NBASC,NBAS,1.D0,SCR(ISTART3),NBASC,
     &            SCR(ISTART2),NBASC,0.D0,SCR(IDENS),NBASC)

C
C PRINT OUT AO HF-SCF DENSITY MATRIX ...
C **********************************
C       IF(DEBUG) THEN
        write(*,*) ' HF-SCF density matrix D(mu,nu)'
        CALL OUTPUT(SCR(IDENS),1,NBASC,1,NBASC,NBASC,NBASC,1)
C       ENDIF

       atol=1.d-32
       do ijj=idens,idens+nbasc*nbasc-1
           if (dabs(scr(ijj)) < atol) then
             write(42,'(d)') 0.d0
           else
             write(42,'(d)') scr(ijj)
           end if
       end do
       write(42,*) 

C
      ELSE
C
C CORRELATED UNPERTURBED DENSITY MATRIX
C *************************************
C
C  READ TOTAL MO-DENSITY FROM JOBARC
C
       CALL GETREC(20,'JOBARC','RELDENSA',NBAS2*IINTFP,SCR(IDENS))
C
C PRINT OUT MO DENSITY MATRIX ...
C
       IF(DEBUG) THEN
        write(*,*) ' Correlated density matrix D(p,q)'
        CALL OUTPUT(SCR(IDENS),1,NBAS,1,NBAS,NBAS,NBAS,1)
       ENDIF
C
C TRANSFORM CORRELATED (TOTAL) MO DENSITY TO AO BASIS
C
C MEMORY ALLOCATION FOR MOS (KEEP ALSO FOR LATER USE, ADDRES IMO0 !)
C ISTART2 USED FOR SCRATCH
C
       IMO=ISTART
       IMO0=IMO
       ISTART=IMO+NBAS*NBAS
       ISTART2=ISTART
C
       CALL GETREC(20,'JOBARC','SCFEVCA0',NBAS2*IINTFP,SCR(IMO)) 
C
C REFORMAT MO COEFFICIENTS
C
       IF(DEBUG) THEN
         write(*,*) ' MO coefficients c(mu,p)' 
         CALL OUTPUT(SCR(IMO),1,NBAS,1,NBAS,NBAS,NBAS,1)
       ENDIF 
C
C MO--> (S)AO TRANSFORMATION: TWO XGEMM CALLS
C
        CALL XGEMM('N','N',NBAS,NBAS,NBAS,1.D0,SCR(IMO),NBAS,SCR(IDENS),
     &             NBAS,0.D0,SCR(ISTART2),NBAS)
        CALL XGEMM('N','T',NBAS,NBAS,NBAS,1.D0,SCR(ISTART2),NBAS,
     &             SCR(IMO),NBAS,0.D0,SCR(IDENS),NBAS)
c        write(*,*) ' Correlated density matrix D(mu,nu)'
c        CALL OUTPUT(SCR(IDENS),1,NBAS,1,NBAS,NBAS,NBAS,1)
C
C SAO --> CAO TRANSFORMATION; TWO XGEMM CALLS
C
         ISTART3=ISTART2+NBASC*NBAS
         CALL GETREC(20,'JOBARC','CMP2ZMAT',NBAS*NBASC*IINTFP,
     &               SCR(ISTART2))
         CALL XGEMM('N','N',NBASC,NBAS,NBAS,1.D0,SCR(ISTART2),
     &              NBASC,SCR(IDENS),NBAS,0.D0,SCR(ISTART3),NBASC)
         CALL XGEMM('N','T',NBASC,NBASC,NBAS,1.D0,SCR(ISTART3),NBASC,
     &              SCR(ISTART2),NBASC,0.D0,SCR(IDENS),NBASC)
C
C PRINT (TOTAL) CORRELATED AO DENSITY MATRIX
C ******************************************
C
       IF(DEBUG) THEN
        write(*,*) ' Correlated density matrix D(mu,nu)'
        CALL OUTPUT(SCR(IDENS),1,NBASC,1,NBASC,NBASC,NBASC,1)
       ENDIF

       atol=1.d-32
       do ijj=idens,idens+nbasc*nbasc-1
           if (dabs(scr(ijj)) < atol) then
             write(42,'(d)') 0.d0
           else
             write(42,'(d)') scr(ijj)
           end if
       end do
       write(42,*) 
                                           
      ENDIF
C
C PERTURBED DENSITY MATRIX .... MORE TO DO
C ****************************************
C
C  GET FIRST UNPERTURBED MO COEFFICIENTS
C
      IMO=ISTART
      ISTART=IMO+NBAS*NBAS
C
      CALL GETREC(20,'JOBARC','SCFEVCA0',NBAS2*IINTFP,SCR(ISTART)) 
C
C REFORMAT MO COEFFICIENTS
C
      CALL SYMC(SCR(ISTART),SCR(IMO),NBAS,NBASI,.FALSE.,1)
      IF(DEBUG) THEN
         write(*,*) ' MO coefficients c(mu,p)'
c         CALL OUTPUT(SCR(IMO),1,NBAS,1,NBAS,NBAS,NBAS,1)
       call prvecr(scr(imo),nbas*nbas)
      ENDIF
C
C GET MAGNETIC FIELD INFORMATION                    
C
      CALL GETREC(20,'JOBARC','NSYMPERT',27,NTPERT)                             
C
C IRREPS OF B-FIELD COMPONENTS
C
      IRREPB(1)=IYZPERT
      IRREPB(2)=IXZPERT
      IRREPB(3)=IXYPERT
C
C COUNTER FOR B-FIELD PERTURBATION IN EACH IRREP
C
      DO 1 IRREP=1,NIRREP
       IP(IRREP)=0
1     CONTINUE
C
C   LOOP OVER MAGNETIC FIELD COMPONENTS ...
C   ****************************************
C
      ISTART0=ISTART
C
      DO 10 IB=1,3
C
C IRREP OF B-FIELD COMPONENT
C
       IRREPX=IRREPB(IB)
C
C INCREMENT PERTURBATION COUNTER
C
       IP(IRREPX)=IP(IRREPX)+1
C
C MEMORY FOR CPHF COEFFICIENTS AND OVERLAP MATRIX DERIVATIVES
C
       IUAI=ISTART0
       ISIJ=IUAI+IRPDPD(IRREPX,9)
       ISTART=ISIJ+IRPDPD(IRREPX,21)
C 
C READ IN U(A*,I)^x FROM MOINTS FILE
C     
       CALL GETLST(SCR(IUAI),IP(IRREPX),1,1,IRREPX,182)
C
C READ IN S(I*,J)^x FROM MOINTS FILE
C
       CALL GETLST(SCR(ISIJ),IP(IRREPX),1,1,IRREPX,170)
C
C CONVERT S(I,J)^x TO U(I,J)^x (FACTOR -1/2) (NOT FOR PERTURBED 
C CANONICAL ORBITALS, IFLAGS(64).NE.0)
C
       IF(IFLAGS(64).EQ.0) THEN
        CALL SSCAL(IRPDPD(IRREPX,21),HALFM,SCR(ISIJ),1)
       ENDIF
C
C MAKE PERTURBED OCCUPIED MOs
C
C  dc(mu,i)/dx =  sum_p c(mu,p) U(p,i)
C 
       IDMO=ISTART
       ISTART=IDMO+NBAS*NOCA
C
       IOFF1=IDMO
       IOFF2=IMO
       DO 102 IRREP=1,NIRREP
        IOFFDMO(IRREP)=IOFF1
        IOFFMO(IRREP)=IOFF2
        IOFF1=IOFF1+POP(IRREP,1)*NBASI(DIRPRD(IRREP,IRREPX))
        IOFF2=IOFF2+NBASI(IRREP)*NBASI(IRREP)
102    CONTINUE
C
       DO 101 IRREP=1,NIRREP
C
        IRREPMU=IRREP
        IRREPP=IRREP
        IRREPI=DIRPRD(IRREPX,IRREP)
C
        NOCI=POP(IRREPI,1)
        NB=NBASI(IRREPMU)
        NOCP=POP(IRREPP,1)
        NVRTP=VRT(IRREPP,1)
C
        IOFFU=IUAI-1+ISYMOFF(IRREPI,IRREPX,9)
        IOFFS=ISIJ-1+ISYMOFF(IRREPI,IRREPX,21)
        IOFFDM=IOFFDMO(IRREPI)
        IOFFM=IOFFMO(IRREPP)
C
        DO 100 I=1,NOCI 
         DO 100 IMU=1,NB
          INDEX=IOFFDM-1+IMU+(I-1)*NB
          SUM=0.D0
          DO 110 M=1,NOCP
           INDEX1=IOFFM-1+IMU+(M-1)*NB
           INDEX2=IOFFS-1+M+(I-1)*NOCP
           SUM=SUM+SCR(INDEX1)*SCR(INDEX2)
110       CONTINUE
          DO 120 IE=1,NVRTP
           INDEX1=IOFFM-1+IMU+(IE+NOCP-1)*NB
           INDEX2=IOFFU-1+IE+(I-1)*NVRTP
           SUM=SUM+SCR(INDEX1)*SCR(INDEX2)
120       CONTINUE
          SCR(INDEX)=SUM
100     CONTINUE
101    CONTINUE
C
       IF(DEBUG) THEN 
        write(*,*) ' perturbed MO coefficients dc(mu,i)/dx'
        CALL OUTPUT(SCR(IDMO),1,NBAS,1,NOCA,NBAS,NOCA,1)
       ENDIF
C
C CONSTRUCT PERTURBED DENSITY MATRIX
C
C  dD(nu,mu)/dx = sum_i [dc(mu,i)*/dx c(nu,i) + c(mu,i) dc(nu,i)/dx]
C
       IDDENS=ISTART
       ISTART=IDDENS+NBASC*NBASC
       IOFFDD=IDDENS
       DO 201 IRREP=1,NIRREP
        IRREPMU=IRREP
        IRREPNU=DIRPRD(IRREP,IRREPX)
        NBASMU=NBASI(IRREPMU)
        NBASNU=NBASI(IRREPNU)
        NOCMU=POP(IRREPMU,1)
        NOCNU=POP(IRREPNU,1)
        DO 200 IMU=1,NBASMU
         DO 200 INU=1,NBASNU
          INDEX=IOFFDD+INU-1+(IMU-1)*NBASNU
          SUM=0.D0
          DO 210 I=1,NOCNU
           INDEX2=IOFFMO(IRREPNU)+INU-1+(I-1)*NBASNU
           INDEXD1=IOFFDMO(IRREPNU)+IMU-1+(I-1)*NBASMU
           SUM=SUM+2.D0*(SCR(INDEX2)*SCR(INDEXD1))
210       CONTINUE
          DO 211 I=1,NOCMU
           INDEX1=IOFFMO(IRREPMU)+IMU-1+(I-1)*NBASMU
           INDEXD2=IOFFDMO(IRREPMU)+INU-1+(I-1)*NBASNU
           SUM=SUM-2.D0*(SCR(INDEXD2)*SCR(INDEX1))
211       CONTINUE
          SCR(INDEX)=SUM
200     CONTINUE
        IOFFDD=IOFFDD+NBASMU*NBASNU
201    CONTINUE
C
C SAO --> CAO TRANSFORMATION; TWO XGEMM CALLS
C
        CALL SYMC2(SCR(ISTART),SCR(IDDENS),NBAS,NBASI,.FALSE.,1,IRREPX)
C
        CALL SCOPY(NBAS*NBAS,SCR(ISTART),1,SCR(IDDENS),1)
C
        ISTART2=ISTART
        ISTART3=ISTART2+NBASC*NBAS
        CALL GETREC(20,'JOBARC','CMP2ZMAT',NBAS*NBASC*IINTFP,
     &              SCR(ISTART2))
        CALL XGEMM('N','N',NBASC,NBAS,NBAS,1.D0,SCR(ISTART2),
     &             NBASC,SCR(IDDENS),NBAS,0.D0,SCR(ISTART3),NBASC)
        CALL XGEMM('N','T',NBASC,NBASC,NBAS,1.D0,SCR(ISTART3),NBASC,
     &             SCR(ISTART2),NBASC,0.D0,SCR(IDDENS),NBASC)
C
C PERTURBED HF-SCF DENSITY MATRIX
C *******************************
C
         IF(IFLAGS(2).EQ.0.OR.DEBUG) THEN
       write(*,*) ' final perturbed HF-SCF density matrix dD(mu,nu)/dx'
            CALL OUTPUT(SCR(IDDENS),1,NBASC,1,NBASC,NBASC,NBASC,1)
         ENDIF
         
         If(IFLAGS(2).EQ.0) THEN
            do ijj=iddens,iddens+nbasc*nbasc-1
               if (dabs(scr(ijj)) < atol) then
                 write(42,'(d)') 0.d0
               else
                 write(42,'(d)') scr(ijj)
               end if
            end do
            write(42,*)
         ENDIF
C
         IF(IFLAGS(2).NE.0) THEN
C
C ADD ELECTRON-CORRELATED CONTRIBUTION
C
C READ CONTRIBUTION FROM DDXDF .... DDOO, DDVV, DDVO
C
          ISCR1=ISTART
          ISCR2=ISCR1+NBASC*NBASC
          CALL ZERO(SCR(ISCR1),NBAS*NBAS)
C
          CALL READPD(SCR(ISCR1),SCR(ISCR2),NOCA,NVRTA,NBAS,1,IB,IRREPX)
C
C READ CONTRIBUTION FROM DDXDF1 ... DDOO (PERTURBED CANONICAL ORBITALS ONLY) 
C
          IF(IFLAGS(64).NE.0) THEN
C
           CALL READPD(SCR(ISCR1),SCR(ISCR2),NOCA,NVRTA,NBAS,2,IB,
     &                 IRREPX)
C
          ENDIF
C
C READ CONTRIBUTION FROM DDXDF2 ... DDVO 
C
          CALL READPD(SCR(ISCR1),SCR(ISCR2),NOCA,NVRTA,NBAS,3,IB,IRREPX)
C
C  TRANSFORM FROM MO TO AO BASIS: TWO XGEMM CALLS
C
       CALL XGEMM('N','N',NBAS,NBAS,NBAS,1.D0,SCR(IMO0),NBAS,SCR(ISCR1),
     &            NBAS,0.D0,SCR(ISCR2),NBAS)
       CALL XGEMM('N','T',NBAS,NBAS,NBAS,1.D0,SCR(ISCR2),NBAS,
     &            SCR(IMO0),NBAS,0.D0,SCR(ISCR1),NBAS)
       ISTART2=ISCR2
       ISTART3=ISTART2+NBAS*NBASC
       CALL GETREC(20,'JOBARC','CMP2ZMAT',NBAS*NBASC*IINTFP,
     &             SCR(ISTART2))
       CALL XGEMM('N','N',NBASC,NBAS,NBAS,1.D0,SCR(ISTART2),
     &             NBASC,SCR(ISCR1),NBAS,0.D0,SCR(ISTART3),NBASC)
       CALL XGEMM('N','T',NBASC,NBASC,NBAS,1.D0,SCR(ISTART3),NBASC,
     &            SCR(ISTART2),NBASC,0.D0,SCR(ISCR1),NBASC)
C
C ADD CORRELATION CONTRIBUTION TO HF PART
C
       CALL SAXPY(NBASC*NBASC,1.D0,SCR(ISCR1),1,SCR(IDDENS),1)
C
C ANTISYMMETRIZE PERTURBED DENSITY MATRIX: D(mu,nu) = 1/2 (D(mu,nu) - D(nu,mu))
C
       DO 124 I=1,NBASC
        DO 124 J=1,NBASC
         INDEX1=IDDENS-1+I+(J-1)*NBASC
         INDEX2=IDDENS-1+J+(I-1)*NBASC
         A=(SCR(INDEX1)-SCR(INDEX2))/2.D0
         SCR(INDEX1)=A
         SCR(INDEX2)=-A
124    CONTINUE
C
C PERTURBED CORRELATED DENSITY MATRIX
C ***********************************
C
         IF(DEBUG) THEN
            write(*,*) ' perturbed correlated density matrix',
     &                 '  dD(mu,nu)/dx'
            CALL OUTPUT(SCR(IDDENS),1,NBASC,1,NBASC,NBASC,NBASC,1)
         ENDIF
         
         do ijj=iddens,iddens+nbasc*nbasc-1
               if (dabs(scr(ijj)) < atol) then
                 write(42,'(d)') 0.d0
               else
                 write(42,'(d)') scr(ijj)
               end if
         end do
         write(42,*) 

         ENDIF
C
C CHECK PERTURBED DENSITY MATRICES BY COMPUTING PARAMAGNETIC SHIELDINGS
C
ctest         CALL GETREC(20,'JOBARC','NREALATM',1,NATOMS)
ctest         DO 300 INUC=1,3*NATOMS
C
C GET dh(mu,nu)/dm AND EXPAND TO FULL SQUARE MATRIX
C
ctest            CALL GETLST(SCR(ISTART),INUC+3,1,1,1,102)
ctest            CALL MATEXP(1,NBAS,SCR(ISTART),SCR(ISTART+NBAS2),1)
ctest            IF(DEBUG) THEN
ctest               call output(scr(istart+nbas2),1,nbas,1,nbas,nbas,nbas,1)
ctest            ENDIF
C 
C CONTRACTION   dh(mu,nu)/dm * dD(mu,nu)/dB
C
ctest            A=FACT*SDOT(NBAS2,SCR(ISTART+NBAS2),1,SCR(IDDENS),1)
ctest            write(*,*) ' paramagnetic sigma',a,' for B component',ib,
ctest     &                 ' m component',inuc
ctest300      CONTINUE
10    CONTINUE

      close(42)
C
C ALL DONE, CALL CRAPSO
C
      CALL CRAPSO
C
      STOP
      END
       
      SUBROUTINE MATEXP(IRREP,NUM,A,B,IANTI)
C
C THIS ROUTINE EXPANDS THE A COMPRESSED MATRIX A(P,Q)
C P >= Q TO AN ARRAY A(PQ) WITH P,Q. NOTE THIS ROUTINE 
C EXPECTS THAT THE ARRAY A IS SYMMETRY PACKED.
C
C  INPUT : IRREP  ...  THE IRREP OF THE CORRESPONDING PART OF A
C          NUM ......  POPULATION VECTOR FOR I AND J
C          DISSIZE ..  DISTRIBUTION SIZE OF A
C          A     ....  THE MATRIX A
C          IANTI ..... 0 FOR SYMMETRIC AND 1 FOR ANTISYMMETRIC
C                      MATRICES
C
C  OUTPUT : B .......  THE EXPANDED MATRIX A
C
CEND
C
C CODED JG JAN/91
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      INTEGER DIRPRD
      DIMENSION A(*),B(*),NUM(8)
      DIMENSION IPOLD(8),IPNEW(8)
C
      COMMON /SYMINF/NSTART,NIRREP,IRREPA(255),IRREPB(255),
     &DIRPRD(8,8)
C
      IND(J,I)=(J*(J-1))/2+I
C 
      DATA ZERO /0.0D0/
C
C TAKE HERE CARE, IF WE ARE HANDLING IRREP=1 (TOTAL SYMMETRIC)
C OR IRREP=1 (OTHERWISE)
C
      IF(IRREP.EQ.1) THEN
C
C GET FIRST POINTERS FOR OLD AND NEW INDICES
C
       IPOLD(1)=0
       IPNEW(1)=0
       DO 10 IRREPJ=1,(NIRREP-1)
        IPOLD(IRREPJ+1)=IPOLD(IRREPJ)+(NUM(IRREPJ)*(NUM(IRREPJ)+1))/2
        IPNEW(IRREPJ+1)=IPNEW(IRREPJ)+NUM(IRREPJ)**2
10     CONTINUE
C
C NOW LOOP OVER ALL IRREPS
C
       DO 1 IRREPJ=1,NIRREP
        NUMJ=NUM(IRREPJ)
        IPO=IPOLD(IRREPJ)
        IPN=IPNEW(IRREPJ)
C
C LOOP OVER ORBITALS, BUT ALSO IN BACKWARD ORDER
C
        IF(IANTI.EQ.0) THEN
         DO 100 J=1,NUMJ
          DO 100 I=1,J
           IND1=IND(J,I)+IPO
           IND2=(J-1)*NUMJ+I+IPN
           IND3=(I-1)*NUMJ+J+IPN
           B(IND2)=A(IND1)
           B(IND3)=A(IND1)
100      CONTINUE
        ELSE
         DO 101 J=1,NUMJ
          DO 101 I=1,J
           IND1=IND(J,I)+IPO
           IND2=(J-1)*NUMJ+I+IPN
           IND3=(I-1)*NUMJ+J+IPN 
           B(IND2)=A(IND1)
           B(IND3)=-A(IND1)
101      CONTINUE
        ENDIF
C
1      CONTINUE
      ELSE
C
C FILL THE POINTERS OF THE OLD AND NEW ARRAY
C
      IPOLD(1)=0
      IPNEW(1)=0
      DO 1000 IRREPJ=1,NIRREP-1
       IRREPI=DIRPRD(IRREP,IRREPJ)
       NUMJ=NUM(IRREPJ)
       NUMI=NUM(IRREPI)
       IPNEW(IRREPJ+1)=IPNEW(IRREPJ)+NUMJ*NUMI
       IF(IRREPI.LT.IRREPJ) THEN
        IPOLD(IRREPJ+1)=IPOLD(IRREPJ)+NUMJ*NUMI
       ELSE
        IPOLD(IRREPJ+1)=IPOLD(IRREPJ)
       ENDIF
1000  CONTINUE
C
C NOW COPY OLD ARRAYS TO NEW LOCATION
C
      DO 2000 IRREPJ=1,NIRREP
       IRREPI=DIRPRD(IRREP,IRREPJ)
       NUMJ=NUM(IRREPJ)
       NUMI=NUM(IRREPI)
       IF(IRREPJ.GT.IRREPI) THEN
        IPN=IPNEW(IRREPJ)
        IPO=IPOLD(IRREPJ)
        DO 2100 IJ=1,NUMJ*NUMI
        IPNN=IPN+IJ
        IPOO=IPO+IJ
         B(IPNN)=A(IPOO)
2100    CONTINUE
       ELSE
        IF(IANTI.EQ.0) THEN
         IPN=IPNEW(IRREPJ)
         IPO=IPOLD(IRREPI)
         DO 2200 J=1,NUMJ
          DO 2200 I=1,NUMI
           IND1=(I-1)*NUMJ+J+IPO
           IND2=(J-1)*NUMI+I+IPN
           B(IND2)=A(IND1)
2200     CONTINUE
        ELSE
         IPN=IPNEW(IRREPJ)
         IPO=IPOLD(IRREPI)
         DO 2201 J=1,NUMJ
          DO 2201 I=1,NUMI
           IND1=(I-1)*NUMJ+J+IPO
           IND2=(J-1)*NUMI+I+IPN
           B(IND2)=-A(IND1)
2201     CONTINUE
        ENDIF
       ENDIF
2000  CONTINUE
      ENDIF
      RETURN
      END
      SUBROUTINE READPD(DDENS,SCR,NOCA,NVRTA,NBAS,INUMBER,IB,IRREPX)
C   
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      INTEGER POP,VRT,DIRPRD
      DIMENSION DDENS(*),SCR(*),IOFFO(8),IOFFV(8)
C
      COMMON/MACHSP/IINTLN,IFLTLN,IINTFP,IALONE,IBITWD
      COMMON/SYMPOP/IRPDPD(8,22),ISYTYP(2,500),NJUNK(18)
      COMMON/SYMINF/NSTART,NIRREP,IRREPS(255,2),DIRPRD(8,8)
      COMMON/SYM/POP(8,2),VRT(8,2),NT(2),NF1(2),NF2(2)
C
      NLENGTH=IRPDPD(IRREPX,21)+IRPDPD(IRREPX,19)+IRPDPD(IRREPX,9)
C
      IOFF=0
      DO 10 IRREP=1,NIRREP
       IOFFO(IRREP)=IOFF
       IOFF=IOFF+POP(IRREP,1)
10    CONTINUE
      DO 11 IRREP=1,NIRREP
       IOFFV(IRREP)=IOFF
       IOFF=IOFF+VRT(IRREP,1)
11    CONTINUE
C
      IF(INUMBER.EQ.1) THEN
       IF(IB.EQ.1)CALL GETREC(20,'JOBARC','PDENSC1X',NLENGTH*IINTFP,SCR)
       IF(IB.EQ.2)CALL GETREC(20,'JOBARC','PDENSC1Y',NLENGTH*IINTFP,SCR)
       IF(IB.EQ.3)CALL GETREC(20,'JOBARC','PDENSC1Z',NLENGTH*IINTFP,SCR)
      ELSE IF(INUMBER.EQ.2) THEN
       IF(IB.EQ.1)CALL GETREC(20,'JOBARC','PDENSC2X',NLENGTH*IINTFP,SCR)
       IF(IB.EQ.2)CALL GETREC(20,'JOBARC','PDENSC2Y',NLENGTH*IINTFP,SCR)
       IF(IB.EQ.3)CALL GETREC(20,'JOBARC','PDENSC2Z',NLENGTH*IINTFP,SCR)
      ELSE IF(INUMBER.EQ.3) THEN
       IF(IB.EQ.1)CALL GETREC(20,'JOBARC','PDENSC3X',NLENGTH*IINTFP,SCR)
       IF(IB.EQ.2)CALL GETREC(20,'JOBARC','PDENSC3Y',NLENGTH*IINTFP,SCR)
       IF(IB.EQ.3)CALL GETREC(20,'JOBARC','PDENSC3Z',NLENGTH*IINTFP,SCR)
      ENDIF
C
C DEAL WITH OCCUPIED-OCCUPIED BLOCK 
C
      IOFF=0
      DO 90 IRREPR=1,NIRREP
       IRREPL=DIRPRD(IRREPX,IRREPR)
       NOCR=POP(IRREPR,1)
       NOCL=POP(IRREPL,1)
       DO 100 I=1,NOCR
        DO 100 J=1,NOCL
         IOFF=IOFF+1
         INDEX2=J+IOFFO(IRREPL)+(I+IOFFO(IRREPR)-1)*NBAS
         DDENS(INDEX2)=DDENS(INDEX2)+SCR(IOFF)
100    CONTINUE
90    CONTINUE
C
C DEAL WITH VIRTUAL-VIRTUAL BLOCK 
C
      DO 190 IRREPR=1,NIRREP
       IRREPL=DIRPRD(IRREPX,IRREPR)
       NVRTR=VRT(IRREPR,1)
       NVRTL=VRT(IRREPL,1)
       DO 200 I=1,NVRTR
        DO 200 J=1,NVRTL
         IOFF=IOFF+1
         INDEX2=J+IOFFV(IRREPL)+(I+IOFFV(IRREPR)-1)*NBAS
         DDENS(INDEX2)=DDENS(INDEX2)+SCR(IOFF)
200    CONTINUE
190   CONTINUE
C
C DEAL WITH VIRTUAL-OCCUPIED BLOCK 
C
      DO 290 IRREPR=1,NIRREP
       IRREPL=DIRPRD(IRREPX,IRREPR)
       NOCR=POP(IRREPR,1)
       NVRTL=VRT(IRREPL,1)
       DO 300 I=1,NOCR
        DO 300 J=1,NVRTL
         IOFF=IOFF+1
         INDEX2=J+IOFFV(IRREPL)+(I+IOFFO(IRREPR)-1)*NBAS
         INDEX3=I+IOFFO(IRREPR)+(J+IOFFV(IRREPL)-1)*NBAS
         DDENS(INDEX2)=DDENS(INDEX2)+SCR(IOFF)
         DDENS(INDEX3)=DDENS(INDEX3)-SCR(IOFF)
300    CONTINUE
290   CONTINUE
C
      RETURN
      END

      

      SUBROUTINE REORDC(A,SCR,NBAST,POP,VRT,NBAS)
C
C   THIS SUBROUTINE REORDERS A GIVEN MATRIX IN SUCH A WAY THAT
C   ABACUS (CALCULATOR AND IN THE FUTURE CRAY) CAN HANDLE THE
C   BACK TRANSFORMATION OF THE ONE-ELECTRON DENSITY MATRIX
C
C   A ... .... INPUT ARRAY
C   SCR ...... OUTPUT ARRAY
C   NBAST .... TOTAL NUMBER OF BASIS FUNCTIONS
C   POP ...... NUMBER OF OCCUPIED ORBITALS PER IRREP
C   VRT ...... NUMBER OF VIRTUAL ORBITALS PER IRREP
C   NBAS ..... NUMBER OF BASIS FUNCTIONS PER IRREP
C
CEND
C
C CODED OCT/90 JG
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      INTEGER DIRPRD,POP,VRT
      DIMENSION A(NBAST*NBAST),SCR(NBAST*NBAST)
      DIMENSION POP(8),VRT(8),NBAS(8)
C
      COMMON/MACHSP/IINTLN,IFLTLN,IINTFP,IALONE,IBITWD
      COMMON/SYMINF/NSTART,NIRREP,IRREPA(255,2),DIRPRD(8,8)
C
C COPY FIRT CFULL TO SCRATCH
C
      CALL myicopy(A,SCR,NBAST*NBAST*IINTFP)
C
C  OFFSET FOR OCCUPIED AND VIRTUAL BLOCK
C
      IOFFO=1
      IOFFV=1
      DO 10 IRREP=1,NIRREP
       IOFFV=IOFFV+POP(IRREP)*NBAST
10    CONTINUE
C
C  OFFSET FOR TARGET ARRAY
C
      IOFFT=1
C
C  LOOP OVER ALL IRREPS
C
      DO 100 IRREP=1,NIRREP
C
C FILL FIRST WITH OCCUPIED ORBITALS OF THIS BLOCK
C
       CALL myicopy(SCR(IOFFO),A(IOFFT),IINTFP*POP(IRREP)*NBAST)
C
       IOFFO=IOFFO+NBAST*POP(IRREP)
       IOFFT=IOFFT+NBAST*POP(IRREP)
C
C FILL NOW WITH VIRTUAL ORBITALS OF THIS BLOCK
C
       CALL myicopy(SCR(IOFFV),A(IOFFT),IINTFP*VRT(IRREP)*NBAST)
C
       IOFFV=IOFFV+NBAST*VRT(IRREP)
       IOFFT=IOFFT+NBAST*VRT(IRREP)
C
100   CONTINUE
C
C  ALL DONE, RETURN
C
      RETURN
      END
      SUBROUTINE SYMC(CFULL,CSYM,NBAST,NBAS,SCF,ISPIN)
C
C  THIS SUBROUTINE RETURNS THE SYMMETRY PACKED LIST OF THE INPUT
C  MATRIX CFULL. IT IS USED IN THE INTEGRAL DERIVATIVE CODE TO
C  SYMMETYRY PACK THE EIGEN VECTOR MATRIX.
C
C
C  CFULL ..... INPUT MATRIX ( SIZE NBAST*NBAST)
C  CSYM ...... SYMMETRY PACKED OUTPUT MATRIX (SQUARE MATRICES WITHIN
C                                             EACH IRREP)
C  NBAST ..... TOTAL NUMBER OF BASIS FUNCTION
C  NBAS ...... NUMBER OF BASIS FUNCTION PER IRREP( ARRAY OF DIM 8)
C  SCF ....... FLAG WHICH TELLS IF THE EIGENVECTORS HAVE BEEN REORDERED
C              OR NOT.
C              SCF = .TRUE.   NO REORDERING REQUIRED HERE
C                  = .FALSE.  REORDERING IS REQUIRED
C  ISPIN ..... SPIN CASE (AS USUAL)
C
CEND
C
C   CODED OCT/90   JG
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      INTEGER DIRPRD,POP,POPFULL,VRT
      LOGICAL SCF
      DIMENSION CFULL(NBAST,NBAST),CSYM(*),NBAS(8),POPFULL(8)
C
      COMMON/FLAGS/IFLAGS(100)
      COMMON/SYMINF/NSTART,NIRREP,IRREPA(255,2),DIRPRD(8,8)
      COMMON/SYM/POP(8,2),VRT(8,2),NT(2),NF1(2),NF2(2)
C
C
C  FOR CORRELATION METHODS REORDER C SO THAT WE HAVE ALL EIGENVECTORS
C  OF THE SAME IRREP TOGETHER
C
      CALL REORDC(CFULL,CSYM,NBAST,POP(1,1),VRT(1,1),NBAS)
C
      IOFFR=1
      IOFFC=0
      IOFFP=1
C
      DO 10 IRREP=1,NIRREP
       DO 20 IMO=1,NBAS(IRREP)
        IOFFC=IOFFC+1
        LENGTH=NBAS(IRREP)
        CALL SCOPY(LENGTH,CFULL(IOFFR,IOFFC),1,CSYM(IOFFP),1)
        IOFFP=IOFFP+LENGTH
20     CONTINUE
       IOFFR=IOFFR+NBAS(IRREP)
10    CONTINUE
C
C  ALL DONE,  RETURN
C
      RETURN
      END 
      SUBROUTINE SYMC2(CFULL,CSYM,NBAST,NBAS,SCF,ISPIN,IRREPX)
C
C  THIS SUBROUTINE RETURNS THE SYMMETRY PACKED LIST OF THE INPUT
C  MATRIX CFULL. IT IS USED IN THE INTEGRAL DERIVATIVE CODE TO
C  SYMMETYRY PACK THE EIGEN VECTOR MATRIX.
C
C
C  CFULL ..... OUTPUT MATRIX ( SIZE NBAST*NBAST)
C  CSYM ...... SYMMETRY PACKED INPUT MATRIX (SQUARE MATRICES WITHIN
C                                             EACH IRREP)
C  NBAST ..... TOTAL NUMBER OF BASIS FUNCTION
C  NBAS ...... NUMBER OF BASIS FUNCTION PER IRREP( ARRAY OF DIM 8)
C  SCF ....... FLAG WHICH TELLS IF THE EIGENVECTORS HAVE BEEN REORDERED
C              OR NOT.
C              SCF = .TRUE.   NO REORDERING REQUIRED HERE
C                  = .FALSE.  REORDERING IS REQUIRED
C  ISPIN ..... SPIN CASE (AS USUAL)
C  IRREPX .... IRREP OF ARRAY TO BE UNPACKED
CEND
C
C   CODED OCT/90   JG
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      INTEGER DIRPRD,POP,POPFULL,VRT
      LOGICAL SCF
      DIMENSION CFULL(NBAST,NBAST),CSYM(*),NBAS(8),POPFULL(8)
C
      COMMON/FLAGS/IFLAGS(100)
      COMMON/SYMINF/NSTART,NIRREP,IRREPA(255,2),DIRPRD(8,8)
      COMMON/SYM/POP(8,2),VRT(8,2),NT(2),NF1(2),NF2(2)
C
      IOFFR=1
      IOFFC=0
      IOFFP=1
C
      CALL ZERO(CFULL,NBAST*NBAST)
      DO 10 IRREP=1,NIRREP
       DO 20 IMO=1,NBAS(IRREP)
        IOFFC=IOFFC+1
        IRREP2=DIRPRD(IRREP,IRREPX)
        LENGTH=NBAS(IRREP2)
        IOFFR=1
        DO 11 IRREP1=1,IRREP2-1
         IOFFR=IOFFR+NBAS(IRREP1)
11      CONTINUE
        CALL SCOPY(LENGTH,CSYM(IOFFP),1,CFULL(IOFFR,IOFFC),1)
        IOFFP=IOFFP+LENGTH
20     CONTINUE
10    CONTINUE
C
C  ALL DONE,  RETURN
C
      RETURN
      END 

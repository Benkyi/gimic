C
C $Id$
C
      PROGRAM ACEDENS
C
C QUICK AND DIRTY PROGRAM TO GET DENSITY MATRIX AND PERTURBED
C DENSITY MATRICES
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      PARAMETER (MAXCOR=2 000 000)
      LOGICAL DEBUG
      DIMENSION SCR(MAXCOR),IP(8),IRREPB(3) 
      INTEGER DIRPRD
C
      COMMON/MACHSP/IINTLN,IFLTLN,IINTFP,IALONE,IBITWD
      COMMON/SYMINF/NSTART,NIRREP,IRREPS(255,2),DIRPRD(8,8)
      COMMON/SYMPOP/IRPDPD(8,22),ISYTYP(2,500),ID(18) 
      COMMON/FLAGS/IFLAGS(100)
      COMMON/INFO/NOCA,NOCB,NVRTA,NVRTB
      COMMON/PERT/NTPERT,NPERT(8),IPERT(8),IXPERT,IYPERT,IZPERT,
     &            IYZPERT,IXZPERT,IXYPERT,ITRANSX,ITRANSY,ITRANSZ,
     &            NUCIND                                                        
C 
      DATA FACT/26.62568098450085D+00/
      DATA HALFM/-.5D0/
C
C INITIALIZE THIS MODULE
C
      CALL CRAPSI(SCR,IUHF,0)
C
      DEBUG=.FALSE.
C
C NBAS NUMBER OF BASIS FUNCTIONS
C
      NBAS=NOCA+NVRTA
      NBAS2=NBAS*NBAS
C
C UNPERTURBED SCF DENSITY MATRIX ...
C
      IDENS=1
      ISTART=IDENS+NBAS2
C
C READ FROM JOBARC 
C
      CALL GETREC(20,'JOBARC','SCFDENSA',NBAS2*IINTFP,SCR(IDENS))
C
C PRINT OUT AO DENSITY MATRIX ...
C
C      IF(DEBUG) THEN
        write(*,*) ' AO density matrix D(mu,nu)'
        CALL OUTPUT(SCR(IDENS),1,NBAS,1,NBAS,NBAS,NBAS,1)
        
        open(42, file='XDENS')
        
        do ijj=IDENS,IDENS+NBAS*NBAS-1
            write(42,*) SCR(ijj)
        end do
C      END IF

C
C PERTURBED DENSITY MATRIX .... MORE TO DO
C
C
C  GET FIRST UNPERTURBED MO COEFFICIENTS
C
      IMO=ISTART
      ISTART=IMO+NBAS*NBAS
C
      CALL GETREC(20,'JOBARC','SCFEVCA0',NBAS2*IINTFP,SCR(ISTART)) 
C
C REFORMAT MO COEFFICIENTS
C
      CALL SYMC(SCR(ISTART),SCR(IMO),NBAS,NBAS,.FALSE.,1)
      IF(DEBUG) THEN
         write(*,*) ' MO coefficients c(mu,p)'
         CALL OUTPUT(SCR(IMO),1,NBAS,1,NBAS,NBAS,NBAS,1)
      END IF
C
C GET MAGNETIC FIELD INFORMATION                    
C
      CALL GETREC(20,'JOBARC','NSYMPERT',27,NTPERT)                             
C
C IRREPS OF B-FIELD COMPONENTS
C
      IRREPB(1)=IYZPERT
      IRREPB(2)=IXZPERT
      IRREPB(3)=IXYPERT
C
C COUNTER FOR B-FIELD PERTURBATION IN EACH IRREP
C
      DO IRREP=1,NIRREP
       IP(IRREP)=0
      END DO
C
      IF(DEBUG) THEN
         write(*,*) 'loop over magnetic field components'
      END IF
C
C   LOOP OVER MAGNETIC FIELD COMPONENTS ...
C
      DO IB=1,3
C
         IF(DEBUG) THEN
           write(*,*) ' B component:',ib
         END IF
C
C IRREP OF B-FIELD COMPONENT
C
         IRREPX=IRREPB(IB)
C
C INCREMENT PERTURBATION COUNTER
C
         IP(IRREPX)=IP(IRREPX)+1
C
C MEMORY FOR CPHF COEFFICIENTS AND OVERLAP MATRIX DERIVATIVES
C
         IUAI=ISTART
         ISIJ=IUAI+IRPDPD(IRREPX,9)
         ISTART=ISIJ+IRPDPD(IRREPX,21)
C 
C READ IN U(A*,I)^x FROM MOINTS FILE
C     
         CALL GETLST(SCR(IUAI),IP(IRREPX),1,1,IRREPX,182)
C
C READ IN S(I*,J)^x FROM MOINTS FILE
C
         CALL GETLST(SCR(ISIJ),IP(IRREPX),1,1,IRREPX,170)
C
C CONVERT S(I,J)^x TO U(I,J)^x (FACTOR -1/2)
C
         CALL SSCAL(IRPDPD(IRREPX,21),HALFM,SCR(ISIJ),1)
         IF(DEBUG) THEN
            write(*,*) ' CPHF coefficients U(a,i)'
            CALL OUTPUT(SCR(IUAI),1,NVRTA,1,NOCA,NVRTA,NOCA,1)
            write(*,*) ' CPHF coefficients U(j,i)'
            CALL OUTPUT(SCR(ISIJ),1,NOCA,1,NOCA,NOCA,NOCA,1)
         END IF
C
C MAKE PERTURBED OCCUPIED MOs
C
C  dc(mu,i)/dx =  sum_p c(mu,p) U(p,i)
C 
         IDMO=ISTART
         ISTART=IDMO+NBAS*NOCA
         DO I=1,NOCA
            DO IMU=1,NBAS
               INDEX=IDMO-1+IMU+(I-1)*NBAS
               SUM=0.D0
               DO M=1,NOCA
                  INDEX1=IMO-1+IMU+(M-1)*NBAS
                  INDEX2=ISIJ-1+M+(I-1)*NOCA
                  SUM=SUM+SCR(INDEX1)*SCR(INDEX2)
               END DO
               DO IE=1,NVRTA
                  INDEX1=IMO-1+IMU+(IE+NOCA-1)*NBAS
                  INDEX2=IUAI-1+IE+(I-1)*NVRTA
                  SUM=SUM+SCR(INDEX1)*SCR(INDEX2)
               END DO
               SCR(INDEX)=SUM
            END DO
         END DO

         IF(DEBUG) THEN 
            write(*,*) ' perturbed MO coefficients dc(mu,i)/dx'
            CALL OUTPUT(SCR(IDMO),1,NBAS,1,NOCA,NBAS,NOCA,1)
         END IF
C
C CONSTRUCT PERTURBED DENSITY MATRIX
C
C  dD(nu,mu)/dx = sum_i [dc(nu,i)*/dx c(nu,i) + c(mu,i) dc(nu,i)/dx]
C
         IDDENS=ISTART
         ISTART=IDDENS+NBAS*NBAS
         DO IMU=1,NBAS
            DO INU=1,NBAS
               INDEX=IDDENS+INU-1+(IMU-1)*NBAS
               SUM=0.D0
               DO I=1,NOCA
                  INDEX1=IMO+IMU-1+(I-1)*NBAS
                  INDEX2=IMO+INU-1+(I-1)*NBAS
                  INDEXD1=IDMO+IMU-1+(I-1)*NBAS
                  INDEXD2=IDMO+INU-1+(I-1)*NBAS
                  SUM=SUM+2.D0*(SCR(INDEX2)*SCR(INDEXD1)-SCR(INDEXD2)*
     &                          SCR(INDEX1))
               END DO
               SCR(INDEX)=SUM
            END DO
         END DO

C         IF(DEBUG) THEN
            write(*,*) ' perturbed density matrix dD(mu,nu)/dx'
            CALL OUTPUT(SCR(IDDENS),1,NBAS,1,NBAS,NBAS,NBAS,1)
            do ijj=IDDENS,IDDENS+NBAS*NBAS-1
                write(42,*) SCR(ijj)
            end do
C         END IF
C
C CHECK PERTURBED DENSITY MATRICES BY COMPUTING PARAMAGNETIC SHIELDINGS
C
         CALL GETREC(20,'JOBARC','NREALATM',1,NATOMS)
         DO INUC=1,3*NATOMS
C
C GET dh(mu,nu)/dm AND EXPAND TO FULL SQUARE MATRIX
C
            CALL GETLST(SCR(ISTART),INUC+3,1,1,1,102)
            CALL MATEXP(1,NBAS,SCR(ISTART),SCR(ISTART+NBAS2),1)
            IF(DEBUG) THEN
               call output(scr(istart+nbas2),1,nbas,1,nbas,nbas,nbas,1)
            END IF
C 
C CONTRACTION   dh(mu,nu)/dm * dD(mu,nu)/dB
C
            A=FACT*SDOT(NBAS2,SCR(ISTART+NBAS2),1,SCR(IDDENS),1)
            write(*,*) ' paramagnetic sigma',a,' for B component',ib,
     &                 ' m component',inuc
         END DO
      END DO
C
C ALL DONE, CALL CRAPSO
C
      close(42)
      CALL CRAPSO
C
      STOP
      END
       
      SUBROUTINE MATEXP(IRREP,NUM,A,B,IANTI)
C
C THIS ROUTINE EXPANDS THE A COMPRESSED MATRIX A(P,Q)
C P >= Q TO AN ARRAY A(PQ) WITH P,Q. NOTE THIS ROUTINE 
C EXPECTS THAT THE ARRAY A IS SYMMETRY PACKED.
C
C  INPUT : IRREP  ...  THE IRREP OF THE CORRESPONDING PART OF A
C          NUM ......  POPULATION VECTOR FOR I AND J
C          DISSIZE ..  DISTRIBUTION SIZE OF A
C          A     ....  THE MATRIX A
C          IANTI ..... 0 FOR SYMMETRIC AND 1 FOR ANTISYMMETRIC
C                      MATRICES
C
C  OUTPUT : B .......  THE EXPANDED MATRIX A
C
CEND
C
C CODED JG JAN/91
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      INTEGER DIRPRD
      DIMENSION A(*),B(*),NUM(8)
      DIMENSION IPOLD(8),IPNEW(8)
C
      COMMON /SYMINF/NSTART,NIRREP,IRREPA(255),IRREPB(255),
     &DIRPRD(8,8)
C
      IND(J,I)=(J*(J-1))/2+I
C 
      DATA ZERO /0.0D0/
C
C TAKE HERE CARE, IF WE ARE HANDLING IRREP=1 (TOTAL SYMMETRIC)
C OR IRREP=1 (OTHERWISE)
C
      IF(IRREP.EQ.1) THEN
C
C GET FIRST POINTERS FOR OLD AND NEW INDICES
C
       IPOLD(1)=0
       IPNEW(1)=0
       DO 10 IRREPJ=1,(NIRREP-1)
        IPOLD(IRREPJ+1)=IPOLD(IRREPJ)+(NUM(IRREPJ)*(NUM(IRREPJ)+1))/2
        IPNEW(IRREPJ+1)=IPNEW(IRREPJ)+NUM(IRREPJ)**2
10     CONTINUE
C
C NOW LOOP OVER ALL IRREPS
C
       DO 1 IRREPJ=1,NIRREP
        NUMJ=NUM(IRREPJ)
        IPO=IPOLD(IRREPJ)
        IPN=IPNEW(IRREPJ)
C
C LOOP OVER ORBITALS, BUT ALSO IN BACKWARD ORDER
C
        IF(IANTI.EQ.0) THEN
         DO 100 J=1,NUMJ
          DO 100 I=1,J
           IND1=IND(J,I)+IPO
           IND2=(J-1)*NUMJ+I+IPN
           IND3=(I-1)*NUMJ+J+IPN
           B(IND2)=A(IND1)
           B(IND3)=A(IND1)
100      CONTINUE
        ELSE
         DO 101 J=1,NUMJ
          DO 101 I=1,J
           IND1=IND(J,I)+IPO
           IND2=(J-1)*NUMJ+I+IPN
           IND3=(I-1)*NUMJ+J+IPN 
           B(IND2)=A(IND1)
           B(IND3)=-A(IND1)
101      CONTINUE
        END IF
C
1      CONTINUE
      ELSE
C
C FILL THE POINTERS OF THE OLD AND NEW ARRAY
C
      IPOLD(1)=0
      IPNEW(1)=0
      DO 1000 IRREPJ=1,NIRREP-1
       IRREPI=DIRPRD(IRREP,IRREPJ)
       NUMJ=NUM(IRREPJ)
       NUMI=NUM(IRREPI)
       IPNEW(IRREPJ+1)=IPNEW(IRREPJ)+NUMJ*NUMI
       IF(IRREPI.LT.IRREPJ) THEN
        IPOLD(IRREPJ+1)=IPOLD(IRREPJ)+NUMJ*NUMI
       ELSE
        IPOLD(IRREPJ+1)=IPOLD(IRREPJ)
       END IF
1000  CONTINUE
C
C NOW COPY OLD ARRAYS TO NEW LOCATION
C
      DO 2000 IRREPJ=1,NIRREP
       IRREPI=DIRPRD(IRREP,IRREPJ)
       NUMJ=NUM(IRREPJ)
       NUMI=NUM(IRREPI)
       IF(IRREPJ.GT.IRREPI) THEN
        IPN=IPNEW(IRREPJ)
        IPO=IPOLD(IRREPJ)
        DO 2100 IJ=1,NUMJ*NUMI
        IPNN=IPN+IJ
        IPOO=IPO+IJ
         B(IPNN)=A(IPOO)
2100    CONTINUE
       ELSE
        IF(IANTI.EQ.0) THEN
         IPN=IPNEW(IRREPJ)
         IPO=IPOLD(IRREPI)
         DO 2200 J=1,NUMJ
          DO 2200 I=1,NUMI
           IND1=(I-1)*NUMJ+J+IPO
           IND2=(J-1)*NUMI+I+IPN
           B(IND2)=A(IND1)
2200     CONTINUE
        ELSE
         IPN=IPNEW(IRREPJ)
         IPO=IPOLD(IRREPI)
         DO 2201 J=1,NUMJ
          DO 2201 I=1,NUMI
           IND1=(I-1)*NUMJ+J+IPO
           IND2=(J-1)*NUMI+I+IPN
           B(IND2)=-A(IND1)
2201     CONTINUE
        END IF
       END IF
2000  CONTINUE
      END IF
      RETURN
      END
      SUBROUTINE SYMC(CFULL,CSYM,NBAST,NBAS,SCF,ISPIN)
C
C  THIS SUBROUTINE RETURNS THE SYMMETRY PACKED LIST OF THE INPUT
C  MATRIX CFULL. IT IS USED IN THE INTEGRAL DERIVATIVE CODE TO
C  SYMMETYRY PACK THE EIGEN VECTOR MATRIX.
C
C
C  CFULL ..... INPUT MATRIX ( SIZE NBAST*NBAST)
C  CSYM ...... SYMMETRY PACKED OUTPUT MATRIX (SQUARE MATRICES WITHIN
C                                             EACH IRREP)
C  NBAST ..... TOTAL NUMBER OF BASIS FUNCTION
C  NBAS ...... NUMBER OF BASIS FUNCTION PER IRREP( ARRAY OF DIM 8)
C  SCF ....... FLAG WHICH TELLS IF THE EIGENVECTORS HAVE BEEN REORDERED
C              OR NOT.
C              SCF = .TRUE.   NO REORDERING REQUIRED HERE
C                  = .FALSE.  REORDERING IS REQUIRED
C  ISPIN ..... SPIN CASE (AS USUAL)
C
CEND
C
C   CODED OCT/90   JG
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      INTEGER DIRPRD,POP,POPFULL,VRT
      LOGICAL SCF
      DIMENSION CFULL(NBAST,NBAST),CSYM(1),NBAS(8),POPFULL(8)
C
      COMMON/FLAGS/IFLAGS(100)
      COMMON/SYMINF/NSTART,NIRREP,IRREPA(255,2),DIRPRD(8,8)
      COMMON/SYM/POP(8,2),VRT(8,2),NT(2),NF1(2),NF2(2)
C
      IOFFR=1
      IOFFC=0
      IOFFP=1
C
      DO IRREP=1,NIRREP
       DO IMO=1,NBAS(IRREP)
        IOFFC=IOFFC+1
        LENGTH=NBAS(IRREP)
        CALL SCOPY(LENGTH,CFULL(IOFFR,IOFFC),1,CSYM(IOFFP),1)
        IOFFP=IOFFP+LENGTH
       END DO
       IOFFR=IOFFR+NBAS(IRREP)
      END DO

      RETURN
      END 


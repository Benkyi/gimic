module acid_module
     ! H. Fliegl, University of Oslo (2013)
     use globals_module    
     use teletype_module
     use tensor_module
     !use grid_class
     use magnet_module
     implicit none
contains
     function get_acid(r, tens) result(dT2)
     ! purpose: do acid summation of T tensor
     ! see: R. Herges and D. Gruenich,
     !      J. Chem. Phys. A, 105, 3214 (2001)
     !
     !     t_xx t_xy t_xz   1 4 7
     ! T = t_yx t_yy t_yz   2 5 8
     !     t_zx t_zy t_zz   3 6 9
     !
     ! Delta T^2 = 
     !   1/3 [ (t_xx - tyy)^2 + (t_yy - t_zz)^2 + (t_zz - t_xx)^2 ]
     ! + 1/2 [ (t_xy + t_yx)^2 + (t_xz + t_zx)^2 + (t_yz + t_zy)^2 ]
     !
     ! assume: T tensor is written on tens(9:number of points)
     !         first column of T eq. first entries of tens(1:3,npts)
     !
     real(DP), dimension(3), intent(in) :: r
     real(DP), dimension(9), intent(in) :: tens
     real(DP) :: dT2, tmp
     real(DP) :: xxmyy, yymzz, zzmxx, xypyx, xzpzx, yzpzy

     xxmyy = (tens(1) - tens(5))*(tens(1) - tens(5))
     yymzz = (tens(5) - tens(9))*(tens(5) - tens(9))
     zzmxx = (tens(9) - tens(1))*(tens(9) - tens(1))

     xypyx = (tens(4) + tens(2))*(tens(4) + tens(2))
     xzpzx = (tens(7) + tens(3))*(tens(7) + tens(3))
     yzpzy = (tens(8) + tens(6))*(tens(8) + tens(6))

     tmp = DP33*(xxmyy + yymzz + zzmxx) + DP50*(xypyx + xzpzx + yzpzy)  
     ! conversion into SI units nA/T --> done later
     ! dT2 = au2si(tmp)
     dT2 = tmp
     end function

     function get_jav(tens,ptf,rr,rr_2,basvec3) result(jav)
     ! purpose: calculate an average value of J
     ! before:  J_vec = T * B_vec
     ! now:     J_vec_average = sum_p T*B_p 
     !          numerical integration on the surface of a sphere
     !          
     ! see:     Bazant, Z. angew. Math. u. Mech. 66, 1, 37-49 (1986)  
     !          table 1 - 21 point integration scheme ptf = 1
     !          table 2 - 33 point integration scheme ptf = 2
     ! rr_2 = integration grid end point as reference point
     !      = center of mass com
     ! rr   = actual grid point
     !
     real(DP), dimension(9), intent(inout) :: tens
     real(DP), dimension(3) :: rr_2, rr, basvec3
     real(DP), dimension(3) :: jav
     real(DP), dimension(3) :: wb, dtmp
     real(DP), dimension(3) :: coord_a, coord_b, origin, d1vec, d2vec
     real(DP), dimension(3) :: d3vec, d4vec, d5vec, d6vec
     real(DP):: cb, jp
     real(DP), allocatable :: fac(:), tmp(:,:)
     integer(I4) :: i, npts, ptf, idx , idxtmp
     
     ! get coordinates of bond over which the integration 
     ! takes place 
     open(unit=137,file="bond_coord")
     read(137,*) coord_a(1), coord_a(2), coord_a(3) 
     read(137,*) coord_b(1), coord_b(2), coord_b(3) 
     close(137)
     ! new try after discussion with ET
     ! assume coord_a to be the origin
     ! d1vec is vector along the bond defined by a and b
     call get_x2origin_vec(coord_b,coord_a,d1vec)
     ! d2vec is vector from a to the center of mass or
     ! reference point
     call get_x2origin_vec(rr_2,coord_a,d2vec)
     dtmp = d_cross_product(d1vec,d2vec)  

     ! define the origin as the midpoint between the two
     ! coordinates
     ! call get_midpoint(coord_a,coord_b,origin)
     ! define two vectors with respect to the origin and the
     ! integration grid reference point rr_2
     ! all vectors are normalized 
     ! call get_x2origin_vec(coord_a,origin,d1vec)
     ! print *, d1vec
     ! call get_x2origin_vec(rr_2,origin,d2vec)
     ! print *, d2vec
     ! calculate cross product to define z-axis
     ! dtmp = d_cross_product(d1vec,d2vec)  
     ! call get_normalized_vec(dtmp,d3vec)
     ! print *, d3vec
     ! get now vector parallell to the area
     ! dtmp = d_cross_product(d3vec,d1vec)  
     ! call get_normalized_vec(dtmp,d4vec)
     ! print *, d4vec
     ! get vector perpendicular to the area
     ! dtmp = d_cross_product(d4vec,d3vec)  
     ! call get_normalized_vec(dtmp,d5vec)
     ! print *, d5vec
     ! define now +z direction of coordinate system
     ! dtmp = d_cross_product(d1vec,d4vec)  
     ! call get_normalized_vec(dtmp,d6vec)
     ! print *, "d6vec", d6vec

     ! call get_basvec(g, 3, d6vec)

     if (ptf.eq.1) then
       npts = 21
     else if (ptf.eq.2) then
       npts = 33
     else
         print *, "Warning no integration scheme set (21,33)"
     end if  
     allocate(fac(npts))
     allocate(tmp(npts,3))
    
     tmp = 0.0d0 
     jav = 0.0d0 
     idx = 0d0
     ! loop over sphere points
     do i = 1, npts
       ! get spherical coordinates for B_x,B_y,Bz 
       wb = get_swb(i,ptf)
       ! get weight coefficients
       cb = get_scb(i,ptf)
       ! get correct sign factor (dia, para = +-1)
       ! assume d6vec defines +z axis direction
       ! motivation for this: see magnet.f90
       ! case left handed coordinate system
       ! fac(i) = get_factor(basvec3,wb)
       fac(i) = get_factor(dtmp,wb)
       if (fac(i).eq.-1.0d0) then
            wb = -wb
       !    idx = idx + 1
            !print *, "left handed"
        end if
       tmp(i,1:3) = tmp(i,1:3) +                            & 
      &  ( matmul(reshape(tens,(/ 3, 3 /)),wb))*cb
       ! print *, fac(i), i 
     end do
     dtmp = 0.0d0
     do i = 1, npts
       dtmp = dtmp + tmp(i,1:3) 
     end do
     ! 21 points describe only one half sphere 
     ! scale result by a factor of two 
     ! and multiply with the sphere area 4*pi
     !  jav = 2.0d0*4.0d0*PII*tmp 
     ! jav = 8.0d0*PII*tmp 
     ! jav = 8.0d0*PII*dtmp 
     jav = 2.0d0*dtmp 
     ! jav = 8.0d0*PII*dtmp 

     deallocate(fac,tmp)
     end function

     function get_swb(idx,ptf) result(wb)
     ! give spherical coordinates back for one index 
     real(DP), dimension(3) :: wb
     real(DP), allocatable :: weight(:,:)
     integer(I4), intent(inout) :: idx,ptf
     integer(I4) :: i

     if (ptf.eq.1) then
     ! ptf = 1 for 21x2 point formula
       allocate(weight(4,21))
       call get_sphere_dat1(weight) 
     else if (ptf.eq.2) then
     ! ptf = 2 for 33x2 point formula
       allocate(weight(4,33))
       call get_sphere_dat2(weight) 
     else
       write(*,*) "this integration formula is not implemented!"
     end if   
     do i = 1, 3
       wb(i) = weight(i,idx)
     end do
     deallocate(weight)
     end function

     function get_scb(idx,ptf) result(cb)
     ! give spherical weight coefficient back for one index 
     real(DP) :: cb
     real(DP), allocatable :: weight(:,:)
     integer(I4), intent(inout) :: idx, ptf
     
     if (ptf.eq.1) then
     ! ptf = 1 for 21x2 point formula
       allocate(weight(4,21))
       call get_sphere_dat1(weight) 
     else if (ptf.eq.2) then
     ! ptf = 2 for 33x2 point formula
       allocate(weight(4,33))
       call get_sphere_dat2(weight) 
     else
       write(*,*) "this integration formula is not implemented!"
     end if   
     cb = weight(4,idx)
     deallocate(weight)
     end function

     subroutine get_sphere_dat1(weight)
     ! weights for numerical integration on a sphere !
     ! 21x2 point formula
     real(DP), dimension(4,21) :: weight
     real(DP) :: tmp
     integer(I4) :: i
     logical :: debug
     debug = .false.
     ! set up weights !
     ! debug
      weight = 0.0d0
     ! debug

     weight(1,1)=1.0d0
     weight(2,1)=0.0d0
     weight(3,1)=0.0d0
     weight(4,1)=0.0265214244093d0

     weight(1,2)=0.0d0
     weight(2,2)=1.0d0
     weight(3,2)=0.0d0
     weight(4,2)=0.0265214244093d0

     weight(1,3)=0.0d0
     weight(2,3)=0.0d0
     weight(3,3)=1.0d0
     weight(4,3)=0.0265214244093d0

     weight(1,4)=dsqrt(2.d0)/2.d0
     weight(2,4)=dsqrt(2.d0)/2.d0
     weight(3,4)=0.0d0
     weight(4,4)=0.0199301476312d0

     weight(1,5)=dsqrt(2.d0)/2.d0
     weight(2,5)=-dsqrt(2.d0)/2.d0
     weight(3,5)=0.0d0
     weight(4,5)=0.0199301476312d0

     weight(1,6)=dsqrt(2.d0)/2.d0
     weight(2,6)=0.0d0 
     weight(3,6)=dsqrt(2.d0)/2.d0
     weight(4,6)=0.0199301476312d0

     weight(1,7)=dsqrt(2.d0)/2.d0
     weight(2,7)=0.0d0 
     weight(3,7)=-dsqrt(2.d0)/2.d0
     weight(4,7)=0.0199301476312d0

     weight(1,8)=0.0d0 
     weight(2,8)=dsqrt(2.d0)/2.d0
     weight(3,8)=dsqrt(2.d0)/2.d0
     weight(4,8)=0.0199301476312d0

     weight(1,9)=0.0d0 
     weight(2,9)=dsqrt(2.d0)/2.d0
     weight(3,9)=-dsqrt(2.d0)/2.d0
     weight(4,9)=0.0199301476312d0

     weight(1,10)=0.387907304067d0
     weight(2,10)=0.387907304067d0
     weight(3,10)=0.836095596749d0
     weight(4,10)=0.0250712367487d0

     weight(1,11)=0.387907304067d0
     weight(2,11)=0.387907304067d0
     weight(3,11)=-0.836095596749d0
     weight(4,11)=0.0250712367487d0

     weight(1,12)=0.387907304067d0    ! xx
     weight(2,12)=-0.387907304067d0
     weight(3,12)=0.836095596749d0
     weight(4,12)=0.0250712367487d0

     weight(1,13)=0.387907304067d0
     weight(2,13)=-0.387907304067d0
     weight(3,13)=-0.836095596749d0
     weight(4,13)=0.0250712367487d0

     weight(1,14)=0.387907304067d0
     weight(2,14)=0.836095596749d0
     weight(3,14)=0.387907304067d0
     weight(4,14)=0.0250712367487d0

     weight(1,15)=0.387907304067d0
     weight(2,15)=0.836095596749d0
     weight(3,15)=-0.387907304067d0
     weight(4,15)=0.0250712367487d0

     weight(1,16)=0.387907304067d0
     weight(2,16)=-0.836095596749d0
     weight(3,16)=0.387907304067d0
     weight(4,16)=0.0250712367487d0

     weight(1,17)=0.387907304067d0
     weight(2,17)=-0.836095596749d0
     weight(3,17)=-0.387907304067d0
     weight(4,17)=0.0250712367487d0

     weight(1,18)=0.836095596749d0
     weight(2,18)=0.387907304067d0
     weight(3,18)=0.387907304067d0
     weight(4,18)=0.0250712367487d0

     weight(1,19)=0.836095596749d0
     weight(2,19)=0.387907304067d0
     weight(3,19)=-0.387907304067d0
     weight(4,19)=0.0250712367487d0

     weight(1,20)=0.836095596749d0
     weight(2,20)=-0.387907304067d0
     weight(3,20)=0.387907304067d0
     weight(4,20)=0.0250712367487d0

     weight(1,21)=0.836095596749d0
     weight(2,21)=-0.387907304067d0
     weight(3,21)=-0.387907304067d0
     weight(4,21)=0.0250712367487d0

     if (debug) then
       tmp = 0.0d0
       do i = 1, 21
         tmp = tmp + weight(4,i)
         print *, sqrt(weight(1,i)**2 + weight(2,i)**2 + weight(3,i)**2)
       end do
       print *, "tmp =", tmp
     end if
     end subroutine

     subroutine get_sphere_dat2(weight)
     ! weights for numerical integration on a sphere !
     ! 33 x 2 point formula
     real(DP), dimension(4,33) :: weight
     real(DP) :: tmp
     integer(I4) :: i
     logical :: debug
     debug = .false.
     ! set up weights !
     weight(1,1)=  1.0d0
     weight(2,1)=  0.0d0
     weight(3,1)=  0.0d0
     weight(4,1)=  0.00985353993433d0 
                                               
     weight(1,2)=  0.0d0
     weight(2,2)=  1.0d0
     weight(3,2)=  0.0d0
     weight(4,2)=  0.00985353993433d0           
                                               
     weight(1,3)=  0.0d0
     weight(2,3)=  0.0d0
     weight(3,3)=  1.0d0 
     ! weight(3,3)=  0.0d0 
     weight(4,3)=  0.00985353993433d0
                                               
     weight(1,4)=  0.707106781187d0
     weight(2,4)=  0.707106781187d0
     weight(3,4)=  0.0d0           
     weight(4,4)=  0.0162969685886d0 
                                               
     weight(1,5)=  0.707106781187d0
     weight(2,5)= -0.707106781187d0
     weight(3,5)=  0.0d0           
     weight(4,5)=  0.0162969685886d0 
                                               
     weight(1,6)=  0.707106781187d0    
     weight(2,6)=  0.0d0           
     weight(3,6)=  0.707106781187d0
     weight(4,6)=  0.0162969685886d0
                                               
     weight(1,7)=  0.707106781187d0
     weight(2,7)=  0.0d0          
     weight(3,7)= -0.707106781187d0
     weight(4,7)=  0.0162969685886d0
                                               
     weight(1,8)=  0.0d0            
     weight(2,8)=  0.707106781187d0
     weight(3,8)=  0.707106781187d0
     weight(4,8)=  0.0162969685886d0
                                               
     weight(1,9)=  0.0d0
     weight(2,9)=  0.707106781187d0
     weight(3,9)= -0.707106781187d0
     weight(4,9)=  0.0162969685886d0
                                               
     weight(1,10)=  0.933898956394d0             
     weight(2,10)=  0.357537045978d0             
     weight(3,10)=  0.0d0                        
     weight(4,10)=  0.0134788844008d0            
                                                
     weight(1,11)=  0.933898956394d0             
     weight(2,11)= -0.357537045978d0             
     weight(3,11)=  0.0d0                        
     weight(4,11)=  0.0134788844008d0            
                                                
     weight(1,12)=  0.357537045978d0             
     weight(2,12)=  0.933898956394d0             
     weight(3,12)=  0.0d0                        
     weight(4,12)=  0.0134788844008d0            
                                                
     weight(1,13)=  0.357537045978d0             
     weight(2,13)= -0.933898956394d0             
     weight(3,13)=  0.0d0                        
     weight(4,13)=  0.0134788844008d0            
                                                
     weight(1,14)=  0.933898956394d0             
     weight(2,14)=  0.0d0                        
     weight(3,14)=  0.357537045978d0             
     weight(4,14)=  0.0134788844008d0            
                                                
     weight(1,15)=  0.933898956394d0             
     weight(2,15)=  0.0d0                        
     weight(3,15)= -0.357537045978d0             
     weight(4,15)=  0.0134788844008d0            
                                                
     weight(1,16)=  0.357537045978d0             
     weight(2,16)=  0.0d0                        
     weight(3,16)=  0.933898956394d0             
     weight(4,16)=  0.0134788844008d0            
                                                
     weight(1,17)=  0.357537045978d0             
     weight(2,17)=  0.0d0                        
     weight(3,17)= -0.933898956394d0             
     weight(4,17)=  0.0134788844008d0            
                                                
     weight(1,18)=  0.0d0                        
     weight(2,18)=  0.933898956394d0             
     weight(3,18)=  0.357537045978d0             
     weight(4,18)=  0.0134788844008d0            
                                                
     weight(1,19)=  0.0d0                        
     weight(2,19)=  0.933898956394d0             
     weight(3,19)= -0.357537045978d0             
     weight(4,19)=  0.0134788844008d0            
                                                
     weight(1,20)=  0.0d0                        
     weight(2,20)=  0.357537045978d0             
     weight(3,20)=  0.933898956394d0             
     weight(4,20)=  0.0134788844008d0            
                                                
     weight(1,21)=  0.0d0                        
     weight(2,21)=  0.357537045978d0             
     weight(3,21)= -0.933898956394d0             
     weight(4,21)=  0.0134788844008d0            
                                                
     weight(1,22)=  0.437263676092d0             
     weight(2,22)=  0.437263676092d0             
     weight(3,22)=  0.785875915868d0             
     weight(4,22)=  0.0175759129880d0            
                                                
     weight(1,23)=  0.437263676092d0             
     weight(2,23)=  0.437263676092d0             
     weight(3,23)= -0.785875915868d0             
     weight(4,23)=  0.0175759129880d0            
                                                
     weight(1,24)=  0.437263676092d0             
     weight(2,24)= -0.437263676092d0             
     weight(3,24)=  0.785875915868d0             
     weight(4,24)=  0.0175759129880d0            
                                                
     weight(1,25)=  0.437263676092d0             
     weight(2,25)= -0.437263676092d0             
     weight(3,25)= -0.785875915868d0             
     weight(4,25)=  0.0175759129880d0            
                                                
     weight(1,26)=  0.437263676092d0             
     weight(2,26)=  0.785875915868d0             
     weight(3,26)=  0.437263676092d0             
     weight(4,26)=  0.0175759129880d0            
                                                
     weight(1,27)=  0.437263676092d0             
     weight(2,27)=  0.785875915868d0             
     weight(3,27)= -0.437263676092d0             
     weight(4,27)=  0.0175759129880d0            
                                                
     weight(1,28)=  0.437263676092d0             
     weight(2,28)= -0.785875915868d0             
     weight(3,28)=  0.437263676092d0             
     weight(4,28)=  0.0175759129880d0            
                                                
     weight(1,29)=  0.437263676092d0             
     weight(2,29)= -0.785875915868d0             
     weight(3,29)= -0.437263676092d0             
     weight(4,29)=  0.0175759129880d0            
                                                
     weight(1,30)=  0.785875915868d0             
     weight(2,30)=  0.437263676092d0             
     weight(3,30)=  0.437263676092d0             
     weight(4,30)=  0.0175759129880d0            
                                                
     weight(1,31)=  0.785875915868d0             
     weight(2,31)=  0.437263676092d0             
     weight(3,31)= -0.437263676092d0             
     weight(4,31)=  0.0175759129880d0            
                                                
     weight(1,32)=  0.785875915868d0             
     weight(2,32)= -0.437263676092d0             
     weight(3,32)=  0.437263676092d0             
     weight(4,32)=  0.0175759129880d0            
                                                
     weight(1,33)=  0.785875915868d0             
     weight(2,33)= -0.437263676092d0             
     weight(3,33)= -0.437263676092d0             
     weight(4,33)=  0.0175759129880d0             

     if (debug) then
       tmp = 0.0d0
       do i = 1, 33
         tmp = tmp + weight(4,i)
         print *, sqrt(weight(1,i)**2 + weight(2,i)**2 + weight(3,i)**2)
       end do
       print *, "tmp =", tmp
     end if
     end subroutine

     function get_center_of_mass(mol) result(com)
     ! calculate center of mass of molecule to have a reference point
     type(molecule_t) :: mol

     integer(I4) :: i
     real(DP), dimension(3) :: com, tmp
      
     tmp = 0.0d0
     do i = 1, mol%natoms
       tmp(1) = tmp(1) + mol%atoms(i)%coord(1) 
       tmp(2) = tmp(2) + mol%atoms(i)%coord(2) 
       tmp(3) = tmp(3) + mol%atoms(i)%coord(3) 
     end do
     do i = 1, 3
       com(i) = tmp(i)/real(mol%natoms)
         print *, "center of mass", com(i)
     end do
     end function

     function get_factor(a,b) result(factor)
     real(DP), dimension(3) :: a, b
     real(DP) :: factor, tmp
     integer(I4) :: i
     tmp = 0.0d0
     do i = 1, 3
       tmp = tmp + a(i)*b(i)
     end do
     !print *, "tmp for fac", tmp
     if (tmp.gt.0.0d0) then
         factor = +1.0d0
     else
         factor = -1.0d0
     end if
     end function

     subroutine get_midpoint(a,b,c)
     real(DP), dimension(3) :: a, b, c
     integer(I4) :: i
     do i = 1, 3
       c(i) = 0.50d0*a(i) + 0.50d0*b(i)
     end do
     end subroutine

     subroutine get_x2origin_vec(a,o,diff)
     real(DP), dimension(3) :: a, o, diff,tmp
     integer(I4) :: i
     do i = 1, 3
       tmp(i) = a(i) - o(i)
     end do
     call get_normalized_vec(tmp,diff)
     end subroutine

     subroutine get_normalized_vec(a,na)
     real(DP), dimension(3) :: a, na
     real(DP) :: tmp
     integer(I4) :: i
    
     tmp = 0.0d0
     do i = 1, 3
       tmp = tmp + a(i)*a(i)
     end do 
     do i = 1, 3
       na(i) = a(i)/dsqrt(tmp)
     end do
     end subroutine

end module


! vim:et:sw=4:ts=4

module acidplot_module
     use globals_module
     use teletype_module
     use settings_module
     use acid_module
     use jfield_class ! <-- this usage causes trouble
     ! use grid_class

    implicit none

    contains
    subroutine acid_cube_plot(this)
    !type(grid_t) :: grid
    type(jfield_t) :: this
    integer(I4), dimension(3) :: npts
    integer(I4) :: fd1, i, j, k, l, m, idx
    real(DP), dimension(:,:), pointer :: jtens
    real(DP), dimension(3) :: qmin, qmax, step, r 
    real(DP) :: val, maxi, mini

    ! collect grid information
    call get_grid_size(this%grid, npts(1), npts(2), npts(3))
    qmin = gridpoint(this%grid, 1, 1, 1)
    qmax = gridpoint(this%grid, npts(1), npts(2), npts(3))
    step = (qmax - qmin)/(npts - 1)
    ! get T tensor assume that this information is kept
    ! not sure because tens gets deallocated at one point...
    jtens => this%tens
    !                           origin step number of points
    ! no access to original opencube function
    ! fd1 = opencube('acid.cube', qmin, step, npts)
    
     call getfd(fd1)
     if (fd1 == 0) then
         stop 1
     end if

     open(unit=fd1,file='acid.cube',form='formatted', status='unknown')
     write(fd1,*) 'Gaussian cube data, generated by genpot'
     write(fd1,*) 
     write(fd1, '(i5,3f12.6)') 0, qmin
     write(fd1, '(i5,3f12.6)') npts(1), step(1), 0.d0, 0.d0
     write(fd1, '(i5,3f12.6)') npts(2), 0.d0, step(2), 0.d0
     write(fd1, '(i5,3f12.6)') npts(3), 0.d0, 0.d0, step(3)

    maxi = 0.0d0
    mini = 0.0d0
    l = 0
    m = 0
    do i = 1, npts(1)
        do j = 1, npts(2)
            do k = 1, npts(3)
                m = m + 1
                r = gridpoint(this%grid, i, j, k)
                ! maybe better to call ctens here ?? check code !
                ! which index for jtens? --> copy from cube plot file 
                idx = i+(j-1)*npts(1) + (k-1)*npts(1)*npts(2) 
                val = get_acid(r, jtens(:,idx))  
                if (val > maxi) maxi = val 
                if (val > mini) mini = val 
                if (fd1 /= 0) then
                    write(fd1,'(f12.6)',advance='no') val
                    if (mod(l,6) == 5) write(fd1,*)
                end if
                l = l + 1
            end do
        end do
    end do
    print *, 'ACID: maxi, mini', maxi, mini

    call closefd(fd1)
    end subroutine

end module

! vim:et:sw=4:ts=4
